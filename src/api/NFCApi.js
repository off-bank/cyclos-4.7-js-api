/**
 * Cyclos 4.7.1 API
 * The REST API for Cyclos 4.7.1
 *
 * OpenAPI spec version: 4.7.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient', 'model/Error', 'model/ForbiddenError', 'model/InitializeNfcError', 'model/InputError', 'model/NfcAuthError', 'model/NfcDataForInitialize', 'model/NfcDataForPersonalize', 'model/NfcExternalAuthenticateParameter', 'model/NfcExternalAuthenticateResult', 'model/NfcInitializeParameter', 'model/NfcInitializeResult', 'model/NfcPersonalizeOtpParameter', 'model/NfcPersonalizeParameter', 'model/NfcTokenParameter', 'model/NotFoundError', 'model/OtpError', 'model/PersonalizeNfcError', 'model/TokenDetailed', 'model/UnauthorizedError'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'), require('../model/Error'), require('../model/ForbiddenError'), require('../model/InitializeNfcError'), require('../model/InputError'), require('../model/NfcAuthError'), require('../model/NfcDataForInitialize'), require('../model/NfcDataForPersonalize'), require('../model/NfcExternalAuthenticateParameter'), require('../model/NfcExternalAuthenticateResult'), require('../model/NfcInitializeParameter'), require('../model/NfcInitializeResult'), require('../model/NfcPersonalizeOtpParameter'), require('../model/NfcPersonalizeParameter'), require('../model/NfcTokenParameter'), require('../model/NotFoundError'), require('../model/OtpError'), require('../model/PersonalizeNfcError'), require('../model/TokenDetailed'), require('../model/UnauthorizedError'));
  } else {
    // Browser globals (root is window)
    if (!root.Cyclos471Api) {
      root.Cyclos471Api = {};
    }
    root.Cyclos471Api.NFCApi = factory(root.Cyclos471Api.ApiClient, root.Cyclos471Api.Error, root.Cyclos471Api.ForbiddenError, root.Cyclos471Api.InitializeNfcError, root.Cyclos471Api.InputError, root.Cyclos471Api.NfcAuthError, root.Cyclos471Api.NfcDataForInitialize, root.Cyclos471Api.NfcDataForPersonalize, root.Cyclos471Api.NfcExternalAuthenticateParameter, root.Cyclos471Api.NfcExternalAuthenticateResult, root.Cyclos471Api.NfcInitializeParameter, root.Cyclos471Api.NfcInitializeResult, root.Cyclos471Api.NfcPersonalizeOtpParameter, root.Cyclos471Api.NfcPersonalizeParameter, root.Cyclos471Api.NfcTokenParameter, root.Cyclos471Api.NotFoundError, root.Cyclos471Api.OtpError, root.Cyclos471Api.PersonalizeNfcError, root.Cyclos471Api.TokenDetailed, root.Cyclos471Api.UnauthorizedError);
  }
}(this, function(ApiClient, Error, ForbiddenError, InitializeNfcError, InputError, NfcAuthError, NfcDataForInitialize, NfcDataForPersonalize, NfcExternalAuthenticateParameter, NfcExternalAuthenticateResult, NfcInitializeParameter, NfcInitializeResult, NfcPersonalizeOtpParameter, NfcPersonalizeParameter, NfcTokenParameter, NotFoundError, OtpError, PersonalizeNfcError, TokenDetailed, UnauthorizedError) {
  'use strict';

  /**
   * NFC service.
   * @module api/NFCApi
   * @version 4.7.1
   */

  /**
   * Constructs a new NFCApi. 
   * @alias module:api/NFCApi
   * @class
   * @param {module:ApiClient} apiClient Optional API client implementation to use,
   * default to {@link module:ApiClient#instance} if unspecified.
   */
  var exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance;


    /**
     * Callback function to receive the result of the cancelNfc operation.
     * @callback module:api/NFCApi~cancelNfcCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Cancels a NFC tag
     * Cancels a NFC token. Must be authenticated as a manager (administrator / broker) of the token owner, and have the correct permission.  
     * @param {module:model/NfcTokenParameter} params The parameters for canceling. 
     * @param {module:api/NFCApi~cancelNfcCallback} callback The callback function, accepting three arguments: error, data, response
     */
    this.cancelNfc = function(params, callback) {
      var postBody = params;

      // verify the required parameter 'params' is set
      if (params == undefined || params == null) {
        throw new Error("Missing the required parameter 'params' when calling cancelNfc");
      }


      var pathParams = {
      };
      var queryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['session', 'basic', 'accessClient'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = null;

      return this.apiClient.callApi(
        '/nfc/cancel', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the getNfcDataForInitialize operation.
     * @callback module:api/NFCApi~getNfcDataForInitializeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/NfcDataForInitialize} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Returns data for NFC tag initialization. Optionally the user can personalize the tag too.
     * Returns data with the NFC token types the authenticated user can use to initialize NFC tags. 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.fields Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: &#x60;a,b.b1,c.-c1,c.-c2&#x60; will return the fields &#x60;a&#x60;, &#x60;b&#x60; (containing only the &#x60;b1&#x60; field) and &#x60;c&#x60; (containing all its fields except for &#x60;c1&#x60; or &#x60;c2&#x60;).  
     * @param {module:api/NFCApi~getNfcDataForInitializeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/NfcDataForInitialize}
     */
    this.getNfcDataForInitialize = function(opts, callback) {
      opts = opts || {};
      var postBody = null;


      var pathParams = {
      };
      var queryParams = {
        'fields': this.apiClient.buildCollectionParam(opts['fields'], 'multi')
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['session', 'basic', 'accessClient'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = NfcDataForInitialize;

      return this.apiClient.callApi(
        '/nfc/data-for-initialize', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the getNfcDataForPersonalize operation.
     * @callback module:api/NFCApi~getNfcDataForPersonalizeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/NfcDataForPersonalize} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Returns data for perfornalizing an initialized NFC tag for an user
     * Returns data for personalizing a NFC tag for a given user. 
     * @param {String} tokenType The token type reference (id or internal name) of the token principal type, which is stored on the NFC card being personalized.  
     * @param {String} user The user reference (id or an identification method) of the user to whom the NFC tag will be personalized. When authenticated as a manager of that user (administrator or broker) no confirmation password will be required for the personalization. However, if the authenticated user is not a manager, the user will be required a confirmation password. 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.fields Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: &#x60;a,b.b1,c.-c1,c.-c2&#x60; will return the fields &#x60;a&#x60;, &#x60;b&#x60; (containing only the &#x60;b1&#x60; field) and &#x60;c&#x60; (containing all its fields except for &#x60;c1&#x60; or &#x60;c2&#x60;).  
     * @param {module:api/NFCApi~getNfcDataForPersonalizeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/NfcDataForPersonalize}
     */
    this.getNfcDataForPersonalize = function(tokenType, user, opts, callback) {
      opts = opts || {};
      var postBody = null;

      // verify the required parameter 'tokenType' is set
      if (tokenType == undefined || tokenType == null) {
        throw new Error("Missing the required parameter 'tokenType' when calling getNfcDataForPersonalize");
      }

      // verify the required parameter 'user' is set
      if (user == undefined || user == null) {
        throw new Error("Missing the required parameter 'user' when calling getNfcDataForPersonalize");
      }


      var pathParams = {
      };
      var queryParams = {
        'fields': this.apiClient.buildCollectionParam(opts['fields'], 'multi'),
        'tokenType': tokenType,
        'user': user
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['session', 'basic', 'accessClient'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = NfcDataForPersonalize;

      return this.apiClient.callApi(
        '/nfc/data-for-personalize', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the getNfcToken operation.
     * @callback module:api/NFCApi~getNfcTokenCallback
     * @param {String} error Error message, if any.
     * @param {module:model/TokenDetailed} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Retrieve the NFC token detailed data
     * Returns the token&#39;s data and the user owner of the token (i.e the assigned user, if any)
     * @param {String} tokenType The internal name or id of the token type
     * @param {String} value The token value
     * @param {module:api/NFCApi~getNfcTokenCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/TokenDetailed}
     */
    this.getNfcToken = function(tokenType, value, callback) {
      var postBody = null;

      // verify the required parameter 'tokenType' is set
      if (tokenType == undefined || tokenType == null) {
        throw new Error("Missing the required parameter 'tokenType' when calling getNfcToken");
      }

      // verify the required parameter 'value' is set
      if (value == undefined || value == null) {
        throw new Error("Missing the required parameter 'value' when calling getNfcToken");
      }


      var pathParams = {
        'tokenType': tokenType,
        'value': value
      };
      var queryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['session', 'basic', 'accessClient'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = TokenDetailed;

      return this.apiClient.callApi(
        '/nfc/{tokenType}/{value}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the getOtpForPersonalizeNfc operation.
     * @callback module:api/NFCApi~getOtpForPersonalizeNfcCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Generates a new One-Time-Password (OTP) for a personalizing a NFC tag 
     * Sends a new OTP for the customer which will own the NFC tag. The OTP belongs to the NFC tag owner, not the authenticated user. 
     * @param {module:model/String} medium The medium the user wants to receive the otp Possible values are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms) 
     * @param {module:model/NfcPersonalizeOtpParameter} params The parameters identifying the token and the user
     * @param {module:api/NFCApi~getOtpForPersonalizeNfcCallback} callback The callback function, accepting three arguments: error, data, response
     */
    this.getOtpForPersonalizeNfc = function(medium, params, callback) {
      var postBody = params;

      // verify the required parameter 'medium' is set
      if (medium == undefined || medium == null) {
        throw new Error("Missing the required parameter 'medium' when calling getOtpForPersonalizeNfc");
      }

      // verify the required parameter 'params' is set
      if (params == undefined || params == null) {
        throw new Error("Missing the required parameter 'params' when calling getOtpForPersonalizeNfc");
      }


      var pathParams = {
      };
      var queryParams = {
        'medium': medium
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['session', 'basic', 'accessClient'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = null;

      return this.apiClient.callApi(
        '/nfc/personalize/otp', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the initializeNfc operation.
     * @callback module:api/NFCApi~initializeNfcCallback
     * @param {String} error Error message, if any.
     * @param {module:model/NfcInitializeResult} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Initializes a NFC tag
     * Initializes a NFC tag, creating a new &#x60;token&#x60; in Cyclos. Returns the keys (PICC Master Key, Application Master Key and the Operational Key) to be stored on the NFC tag. 
     * @param {module:model/NfcInitializeParameter} params The parameters for initializing the NFC tag. If the &#x60;user&#x60; value is left blank, the NFC tag will be only initialized, but not personalized (assigned to any user). If an user is given, the permission to personalize is required (besides the permission to initialize), and is a shortcut to initializing and later personalizing the tag. The initialization is a sensitive operation, as the result contains the plain keys that should be stored on the NFC tag. Hence, can only be performed by managers (with granted permission). Later on, other users (for example, businesses) will be able to personalize the NFC tag for customers.  
     * @param {module:api/NFCApi~initializeNfcCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/NfcInitializeResult}
     */
    this.initializeNfc = function(params, callback) {
      var postBody = params;

      // verify the required parameter 'params' is set
      if (params == undefined || params == null) {
        throw new Error("Missing the required parameter 'params' when calling initializeNfc");
      }


      var pathParams = {
      };
      var queryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['session', 'basic', 'accessClient'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = NfcInitializeResult;

      return this.apiClient.callApi(
        '/nfc/initialize', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the nfcExternalAuth operation.
     * @callback module:api/NFCApi~nfcExternalAuthCallback
     * @param {String} error Error message, if any.
     * @param {module:model/NfcExternalAuthenticateResult} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * NFC external authentication
     * The NFC tag will normally perform a mutual authentication, by first generating a challenge that must be encrypted by the external system with the device key. With this the external system is authenticated. Cyclos also returns a challenge that should be encrypted by the NFC tag. This challenge can later be passed in specific operations (for example, when performing a payment) for Cyclos to make sure the NFC tag is present on the operation. 
     * @param {module:model/NfcExternalAuthenticateParameter} params The parameters for the external authentication. If the &#x60;token&#x60; value is informed, it will be performed an external authentication with the token itself, using the Application Master Key (AMK). If the &#x60;token&#x60; is not informed, the authentication will be done using the PICC Master Key (PMK), which is useful, for example, when initializing the NFC tag.  
     * @param {module:api/NFCApi~nfcExternalAuthCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/NfcExternalAuthenticateResult}
     */
    this.nfcExternalAuth = function(params, callback) {
      var postBody = params;

      // verify the required parameter 'params' is set
      if (params == undefined || params == null) {
        throw new Error("Missing the required parameter 'params' when calling nfcExternalAuth");
      }


      var pathParams = {
      };
      var queryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['session', 'basic', 'accessClient'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = NfcExternalAuthenticateResult;

      return this.apiClient.callApi(
        '/nfc/external-auth', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the personalizeNfc operation.
     * @callback module:api/NFCApi~personalizeNfcCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Personalizes a NFC tag
     * Personalization requires a NFC tag that was previously initialized, but is still unassigned. This operation doesn&#39;t store any key in the NFC tag itself, hence the plain keys are not returned. What is needed is an external authentication with the NFC tag, in order to ensure the card is physically present. The flow for personalizing a tag is: - &#x60;GET /nfc/data-for-personalize?user&#x3D;{user}&#x60;: Obtain the data for   personalizing NFC tags for this user. The most important information   is which the confirmation password will be required, if any; - &#x60;POST /nfc/external-auth&#x60;: With a challenge previously encrypted by the   NFC tag, invoke this operation. If the challenge matches the NFC token   in Cyclos, it will be encrypted and returned. Also a new challenge will   be returned, which should be then encrypted by the NFC tag for later   being sent back; - &#x60;POST /nfc/personalize&#x60;: With the encrypted challenge and the   confirmation password (if any), this operation will update the NFC   token in Cyclos, so it is now assigned to the specified user. From   this point on, the NFC tag is operational. 
     * @param {module:model/NfcPersonalizeParameter} params The parameters for the initialization. 
     * @param {Object} opts Optional parameters
     * @param {String} opts.confirmationPassword The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
     * @param {module:api/NFCApi~personalizeNfcCallback} callback The callback function, accepting three arguments: error, data, response
     */
    this.personalizeNfc = function(params, opts, callback) {
      opts = opts || {};
      var postBody = params;

      // verify the required parameter 'params' is set
      if (params == undefined || params == null) {
        throw new Error("Missing the required parameter 'params' when calling personalizeNfc");
      }


      var pathParams = {
      };
      var queryParams = {
      };
      var headerParams = {
        'confirmationPassword': opts['confirmationPassword']
      };
      var formParams = {
      };

      var authNames = ['session', 'basic', 'accessClient'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = null;

      return this.apiClient.callApi(
        '/nfc/personalize', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }
  };

  return exports;
}));
