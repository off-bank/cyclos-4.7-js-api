/**
 * Cyclos 4.7.1 API
 * The REST API for Cyclos 4.7.1
 *
 * OpenAPI spec version: 4.7.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient', 'model/CustomField', 'model/CustomFieldControlEnum', 'model/CustomFieldDynamicValue', 'model/CustomFieldPossibleValue', 'model/CustomFieldSizeEnum', 'model/CustomFieldTypeEnum', 'model/EntityReference', 'model/LinkedEntityTypeEnum'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'), require('./CustomField'), require('./CustomFieldControlEnum'), require('./CustomFieldDynamicValue'), require('./CustomFieldPossibleValue'), require('./CustomFieldSizeEnum'), require('./CustomFieldTypeEnum'), require('./EntityReference'), require('./LinkedEntityTypeEnum'));
  } else {
    // Browser globals (root is window)
    if (!root.Cyclos471Api) {
      root.Cyclos471Api = {};
    }
    root.Cyclos471Api.CustomFieldDetailed = factory(root.Cyclos471Api.ApiClient, root.Cyclos471Api.CustomField, root.Cyclos471Api.CustomFieldControlEnum, root.Cyclos471Api.CustomFieldDynamicValue, root.Cyclos471Api.CustomFieldPossibleValue, root.Cyclos471Api.CustomFieldSizeEnum, root.Cyclos471Api.CustomFieldTypeEnum, root.Cyclos471Api.EntityReference, root.Cyclos471Api.LinkedEntityTypeEnum);
  }
}(this, function(ApiClient, CustomField, CustomFieldControlEnum, CustomFieldDynamicValue, CustomFieldPossibleValue, CustomFieldSizeEnum, CustomFieldTypeEnum, EntityReference, LinkedEntityTypeEnum) {
  'use strict';




  /**
   * The CustomFieldDetailed model module.
   * @module model/CustomFieldDetailed
   * @version 4.7.1
   */

  /**
   * Constructs a new <code>CustomFieldDetailed</code>.
   * Contains all information needed to render a widget for a custom field value 
   * @alias module:model/CustomFieldDetailed
   * @class
   * @implements module:model/CustomField
   */
  var exports = function() {
    var _this = this;

    CustomField.call(_this);









  };

  /**
   * Constructs a <code>CustomFieldDetailed</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/CustomFieldDetailed} obj Optional instance to populate.
   * @return {module:model/CustomFieldDetailed} The populated <code>CustomFieldDetailed</code> instance.
   */
  exports.constructFromObject = function(data, obj) {
    if (data) {
      obj = obj || new exports();

      CustomField.constructFromObject(data, obj);
      if (data.hasOwnProperty('informationText')) {
        obj['informationText'] = ApiClient.convertToType(data['informationText'], 'String');
      }
      if (data.hasOwnProperty('size')) {
        obj['size'] = CustomFieldSizeEnum.constructFromObject(data['size']);
      }
      if (data.hasOwnProperty('pattern')) {
        obj['pattern'] = ApiClient.convertToType(data['pattern'], 'String');
      }
      if (data.hasOwnProperty('required')) {
        obj['required'] = ApiClient.convertToType(data['required'], 'Boolean');
      }
      if (data.hasOwnProperty('allSelectedLabel')) {
        obj['allSelectedLabel'] = ApiClient.convertToType(data['allSelectedLabel'], 'String');
      }
      if (data.hasOwnProperty('defaultValue')) {
        obj['defaultValue'] = ApiClient.convertToType(data['defaultValue'], 'String');
      }
      if (data.hasOwnProperty('possibleValueCategories')) {
        obj['possibleValueCategories'] = ApiClient.convertToType(data['possibleValueCategories'], [EntityReference]);
      }
      if (data.hasOwnProperty('possibleValues')) {
        obj['possibleValues'] = ApiClient.convertToType(data['possibleValues'], [CustomFieldPossibleValue]);
      }
      if (data.hasOwnProperty('dynamicValues')) {
        obj['dynamicValues'] = ApiClient.convertToType(data['dynamicValues'], [CustomFieldDynamicValue]);
      }
    }
    return obj;
  }

  /**
   * Additional text that can be shown to the user as a hint of this field 
   * @member {String} informationText
   */
  exports.prototype['informationText'] = undefined;
  /**
   * The size of the widget that should be rendered Possible values are: * tiny: A very small widget * small: A small widget * medium: A medium widget * large: A large widget * full: The widget should occupy 100% of the available area 
   * @member {module:model/CustomFieldSizeEnum} size
   */
  exports.prototype['size'] = undefined;
  /**
   * The mask to be applied to string values. Optional.
   * @member {String} pattern
   */
  exports.prototype['pattern'] = undefined;
  /**
   * Indicates whether this field is required
   * @member {Boolean} required
   */
  exports.prototype['required'] = undefined;
  /**
   * The label to be shown when all values are selected for a  multi selection field. 
   * @member {String} allSelectedLabel
   */
  exports.prototype['allSelectedLabel'] = undefined;
  /**
   * The value that should be suggested as default. For multi selection will be a comma-separated string with possible values ids or internal names. 
   * @member {String} defaultValue
   */
  exports.prototype['defaultValue'] = undefined;
  /**
   * Only applicable when the custom field is enumerated (single or multi select). Contains the possible value categories. 
   * @member {Array.<module:model/EntityReference>} possibleValueCategories
   */
  exports.prototype['possibleValueCategories'] = undefined;
  /**
   * Only applicable when the custom field is enumerated (single or multi selection). Contains the possible values for selection. Each value may or may not have a category. When they have, it will be a string pointing to the internal name (if available) or id of the possible value category, which can be looked up in the categories property. 
   * @member {Array.<module:model/CustomFieldPossibleValue>} possibleValues
   */
  exports.prototype['possibleValues'] = undefined;
  /**
   * Only applicable when the custom field is dynamic selection. Contains the script-generated possible values. 
   * @member {Array.<module:model/CustomFieldDynamicValue>} dynamicValues
   */
  exports.prototype['dynamicValues'] = undefined;

  // Implement CustomField interface:
  /**
   * Entity identifier
   * @member {String} id
   */
exports.prototype['id'] = undefined;

  /**
   * The entity name
   * @member {String} name
   */
exports.prototype['name'] = undefined;

  /**
   * The entity internal name, which can be seen as an extra identifier 
   * @member {String} internalName
   */
exports.prototype['internalName'] = undefined;

  /**
   * The data type for the custom field Possible values are: * string: A single line string * text: A multi line string * richText: A multi line string formatted as HTML * singleSelection: A single enumerated value * multiSelection: Multiple enumerated values * dynamicSelection: Single selection based on options generated by a custom script * integer: An integer value * decimal: A decimal value * date: A date value * boolean: A boolean value * url: An URL * linkedEntity: Another entity. Uses the `linkedEntityType` to define which kind of entity is it 
   * @member {module:model/CustomFieldTypeEnum} type
   */
exports.prototype['type'] = undefined;

  /**
   * When the type is linkedEntity, indicates the entity type Possible values are: * user: An user * transaction: A transaction (payment, scheduled payment, payment request, etc) * transfer: A transfer * record: A record (user or system) * advertisement: An advertisement 
   * @member {module:model/LinkedEntityTypeEnum} linkedEntityType
   */
exports.prototype['linkedEntityType'] = undefined;

  /**
   * The UI control (widget) type that should be used to render this field for edit. Most notably, the types that can have distinct controls are singleSelection, that could be rendered as a single selection widget or radio button group, and multi selection, which could be rendered as a multi selection widget or a checkbox group. Possible values are: * text: A single line text * textarea: A multi line text * richEditor: An HTML editor * singleSelection: A single-selection field * radio: A radio button group * multiSelection: A multi-selection field * checkbox: A checkbox group * entitySelection: A widget to select a linked entity (for example, an auto-complete for users) 
   * @member {module:model/CustomFieldControlEnum} control
   */
exports.prototype['control'] = undefined;



  return exports;
}));


